Vue
4、webpack里的四个核心？并写出四个配置选项
入口(empty中配置)   输出(output中配置)  loader(module下rules中配置)  
插件(plugins中配置)

	vue指令： 
	(1).v-text 
    		<div v-text="变量"></div>
	(2).v-html
    		<div v-html="变量"></div>
	(3).v-show 显示隐藏 所有的dom都会加载，没有缓存，适合频繁切换
    		<div v-show="true/false"></div>
	(4).v-if 条件判断 只加载条件为true的部分，有缓存，适合偶尔的切换
	(5).v-else
	(6).v-else-if
    		<div v-if="条件"></div>
    	<div v-else-if="条件"></div>
    		<div v-else></div>
	(7).v-for 循环
   		 str <div v-for="(i,$index) in str"></div>
   		 arr <div v-for="(i,$index) in arr"></div>
    		json <div v-for="(i,$key,$index) in json"></div>
	(8).v-on 事件绑定 @
    		<div @事件="事件函数($event)"></div>
	(9).v-bind :
    		<div :class=""></div>
	(10).v-pre 跳过渲染
    		<div v-pre></div>
	(11).v-cloak 渲染完成后移除
   		 css:[v-cloak]{display:none;}
    		<div v-cloak></div>
	(12).v-once
    		<div v-once></div>
	(13).v-model input标签
    		文本 单选 下拉："" number
    		多选：[]
	(14).v-bind
    		:style 
        		:style="{color:'',}"
       		 :style="[{color:''},{background:''}]"
   		    :class
        		:class="'a'"
        		:class="['a','b']"
属性：
	实例属性：data methods el watch computed 
	侦听属性：
    		watch:针对一个变量进行监听
    		watch:{
        			name(修改后,修改前){
       			 }
  		          }
	计算属性：computed:
   		 computed:{
        			name(){ return }
    		}
生命周期：
	创建前：beforeCreate
	创建后：created
	渲染前：beforeMount
	渲染后：mounted
	视图变化前：beforeUpdate
	视图变化后：updated
	销毁前：beforeDestroy
	销毁后：destroyed
	组件激活时调用activated
	组件停用时调用 deactivated
	
请求：
	get
    	this.$http.get(url,{params:{}}).then((data)=>{},(err)=>{})
	post
   		this.$http.post(url,{key:vlaue},{emulateJSON:true}).then((data)=>{},(err)=>{})
	jsonp
   		this.$http.get(url,{params:{},callback:'name'}).then((data)=>{},(err)=>{})
git命令
git clone 版本库地址 //把版本库从远程复制到本地 
git remote -v        //查看远程版本库地址 
git status            //查看git状态 
git add .修改的文件   // .：全部文件 =>某个文件  (从红色状态变绿)
git commit -m       //'提交的描述信息' 
git push            //提交远程版本库 
git pull             //拉取远程版本库


git reset HEAD <file>... //撤销暂存的修改
git checkout <file>    // 撤销commit   // 切换分支


事件：
	@click  v-on:click.stop = "指令表达式 1+1  2指令的value"
 	v-on : 指令名
 	click: 指令参数
 	stop : 指令修饰符
 	修饰符可以链式使用
 click修饰符
     .stop === stopPropagation
     .prevent === preventDetault
     .capture 
     .once
     .self  点击自身
 model修饰符
     v-model  
     .number   转换为数字类型
     .lazy  默认input事件触发、  => change触发
     .trim  格式、把前后空格去掉
 键盘修饰符
     数字     keyCode
			.enter 
			 keyName
 事件对象 ： 用$event来传递
new Vue({
         el:'#app',
         methods:{
         tc(i){
            alert(i)
              }
           }
})
自定义指令
directive:
	全局方法：directive
Vue.directive('指令名',function(){});
指令是通过一些规则来操作DOM
钩子函数的第一个参数是DOM对象
钩子函数的第二个参数(指令名 指令参数 指令修饰符 指令表达式 指令的值) 
钩子函数的第三个参数是虚拟DOM VNode
钩子函数：bind() update() inserted() unbind() component
bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。

如果定义的指令参数是一个回调函数，那表示bind和update的简写

全局注册指令 在Vue挂载点的任何地方可以使用
Vue.directive('color',function(el,binding){
	el.style.color=binging.value;
})
Vue.directive('color',{
	bind(el,binding){
		el.style.color=binding.value;
	}
	inserted(el,binding){

		}
		update(el,binding){
			el.style.color=binding.value;
		}
})
Vue.directive('color',function(el,binding){
		console.log(binding.arg)
		console.log(binding.expression)
		console.log(binding.modifiers)
})

computed:
	vm.obj = Object.assign({}, vm.obj, newObj);
 	computed 是个函数返回值
 	必需有data参与
 	一定注意使用场景
 	computed直接定义函数是get的一个简写形式
 	computed是由get、set两个钩子函数定义的
 	set有一个参数来接受computed修改的值
 	watch 可以监听 data和computed
 	watch 的监听直接定义函数其实是handler简写
 	如果要监听对象某个key值，obj.key
 	deep:true属性能深度检测到对象的改变，默认false
 	vue实例方法$watch,,是没有全局方法的
 	vm.$watch(expOrFn，callback，[options])
 	vm.$watch('obj',function(v1,v2){},{
     	deep:true,
 })
 	$watch可以监听一个函数，其实是监听了函数的返回值
vm.$watch(function(){
            return this.msg
        },function(v1,v2){
            console.log(v1)
        })
2、计算属性和方法的区别
计算属性：是基于他们的依赖进行缓存的，只有在相关依赖发生改变时，他们才会重新求值，也就是说，只要他的依赖没有发生变化，那么每次访问的时候计算属性都会立即返回之前的计算结果，不再执行函数
方法：每次触发重新渲染时，调用方法将总会再次执行函数


自定义：
		全局方法：directive
Vue.directive('指令名',function(){});
指令是通过一些规则来操作DOM
钩子函数的第一个参数是DOM对象
钩子函数的第二个参数(指令名 指令参数 指令修饰符 指令表达式 指令的值) 
钩子函数的第三个参数是虚拟DOM  VNode
钩子函数：bind() update() inserted() unbind() component
如果定义的指令参数是一个回调函数,那表示bind和update的简写


全局注册指令 在Vue挂载点的任何地方可以使用
Vue.directive('color',function(el,binding){
		el.style.color=binging.value;
})
Vuw.directive('color',{
		bind(el,binding){
			el.style.color=binding.value;
		}
		inserted(el,binding){

		}
		update(el,binding){
			el.style.color=binding.value;
		}
})


filter：
		forEach map reduce filter sort
filter:过滤一条数据
过滤器  | （管道符）
 computed 与 filter 的区别
filter可以动态传入过滤内容
filter的使用场景： 如果大量数据需要同一种规则改变的话，使用
filter使用的地方
{{}}   /  动态bind的引号里
filter可以传参
data | filtername('filterArg1','filterArg2',...)
接受参数就是通过filter的第二参数，一次类推
第一个参数是要过滤的值
filter可以串联使用（链式调用）

组件：
	组件：可以复用的Vue实例，且带有一个名字 
    通过Vue.sextend()方法返回一个对象
全局注册：Vue.component('参数名',{
            template:'',
            data(){
                return{

                }
            }，
            props:[]
        })
局部注册
    data 必须是一个函数 返回独立拷贝对象
组件之间的传值：父组件和子组件 
   	 	谁使用了组件 谁就是父组件 被使用的就是子组件
   	 	父组件向子组件传值()
        	1.子组件需要统一 props是一个数组(props通过数字来传递只能定义属性名)
       	 	2.父组件如何通过props传入值
子组件怎么告诉父组件传入了什么? 通过$emit(自定义事件名,参数) 通过$event接收
        1.子组件向父组件发送自定义事件 
        2.父组件需要监听子组件的事件 @事件名称
    	v-model(语法糖) == :value + @input
组件插槽: slot
    具名插槽：slot name
        使用：v-slot:插槽名   template标签components 不能再dom对象上
    默认插槽：未指定名字的内容都会统一放入到默认插槽里
    默认插槽 默认名字：default 
    插槽作用域：
动态组件:component is属性
    <component> 通过is=“组件名||组件的选项对象”属性指向组件
    <component is="组件名"></component>如果又两个只渲染一个，同意通过组件名切换
    keep-alive 缓存组件
    <component></component>都放在<keep-alive></keep-alive>
组件的命名规则 事件的命名规则 props的命名规则
    1.组件的命名规则：使用的必须是小写
            定义：驼峰形式 短杠形式(acb-abc||AbcAbc) 全部小写 驼峰形式会加-
            因为一个单词可能会跟原生的dom标签冲突
 2.props的命名规                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         则同上
    3.事件的命名规则：必须是短杠形式(acb-abc)
        props:{
            value{
                type:function,
                requires:true,
                validtaor:function(参数){
                    return v%2==0;
                }
            }
        }
        验证：
        type(类型):string boolean number array function object symbol() Date  
        requires(必传):true false
        validator(自定义):回调函数 return (true false)
        default(默认)： 默认与必传是不能共存的
                    function(){
                        return [1,2,3]
                    }如果是一个数组或者对象，需要一个function函数，返回函数的返回值
组件高级：
    	1.在自定义组件里，不带参数的v-bind相当于传入一个对象的所有属性
    	2.组件里的v-model,相当于把value 属性改为props的值，把input 事件改为event对应的值
    	3.非props类型的属性:会采用覆盖策略替换已有的属性
   	 禁用特性：inheritAttr
组件的单向数据流：
    	1.props的数据第基本数据类型：number string boolean undefined
    	2.props的数据是指向数据类型：object array
    	12456
深拷贝：object.assign
        JSON.parse(JSON.stringfy())  undefined会被转成字符串
        var o={};
        for(var key in obj){
            if(typeof obj[key]=='object'){
                deepCopy(obj[key]);
            }else{
                 o[key]=obj[key];
            }
        }
$refs 来存储dom对象或者是Vue实现对象
$children => Vuecomponent 
$parent => Vuecomponent | vue实例
$root => vue根实例
$nextTick =>局部的update undefined
过渡&动画：
	过渡&动画组件:<transition>
    使用情形：v-if v-show 动态组件(component)  <router><router>
    离开：v-leave v-leave-active v-leave-to
    进入：v-enter v-enter-active v-enter-to
Vue动画必须发生在单个元素的状态切换上
类名的定义：name+ -enter/-enter-active/-enter-to
           name+ -leave/-leave-active/-leave-to
appear 首次出现的动画    
mode(默认为同时进入) 必须是两个元素在切换
    	out-in 先离开在进入
    	in-out 先进入在离开
duration 持续时间
第三方动画：animates
   	 enter-active-class="动画库类名"
// 添加transition属性： enter-active-class  leave-active-class

<transition-group tag="ul"></transition-group> 多个元素 (默认会生成span标签)
children 必须有一个key
tag 设置为ul 标签
动态name:

路由：
	Vue-router安装：npm i --save vue-router
Vue-router：
功能： 嵌套路由 试图表
      模块化基于组件的路由配置

        创建路由实例
        配置路由routes
        注册路由 router:routes
        定义router-view来渲染匹配到的组件
            vue-router是通过#锚点来模拟页面跳转 hash模式
            history模式 更像真是的url 地址  pushState()
            通过vue-link to属性来跳转
                字符串路径: '/abc'
                对象：{path:'/abc'}
            编程式跳转：实例方法：this.$router.push()
                字符串路径: '/abc'
                对象：{path:'/abc'}
定义 
    <router-view></router-view>
创建实例
    var router=new VueRouter({
        mode:'hash', //history
        配置路由
        routes:[
            {
                path:'/abc',
                component:abc
            }
        ]
    })
注册路由到Vue实例中
    new router({
        router:router,
    })
Vue插件的一般功能：添加全局方法或者属性
                  添加全局资源
                  通过全局混入来添加一些组件选项
                  添加一个Vue实例方法
router实例：
    name 路由名字 可以通过name 来跳转路由
    components 可以通过name 来渲染多个不同组件
    redire 重定向
    alias 地址的别名(需要定义成路径格式)
    children 嵌套路由 组件渲染到父级的router-view上 特别注意子级路由不加/
        路由的path 配置不需要
redirect与alias的区别：redirect是直接跳转，url显示的是重定向的地址，alias通过别名(可以多个跳转)来跳转到path的路径下
动态路由：(传参方式)
        在path是哪个定义一个 : +匹配的key
        在params上可以展示动态路由匹配到的参数
        可以串联写多个
        this.$router.currentRoute  === this.$route
通配符 * (一般用于404页面)  通常放到路由配置的最下面
    路由配置是有优先级关系的(从上到下)

路由通过query来传参(参数会显示在url后面或?后面)
    1. to= "/abc?xyz=123"  
    2. :to= "{path:'/abc',query:{xyz=123}}"
    3. $router.push('/abc?xyz=123')
    4. $router.push({path:"/abc",query:{xyz=123}})
params传参
    1. :to="{name:,params:{}}"
    2. $router.push(name:,params:{})(注:如果要用params 传参的话必须用name跳转)
router-link-active: 连接激活时添加的类名，可以通过active-class属性设置
replace属性： $router.replace()
无属性的的话： $router.push();
router.push     跳转添加历史记录
router.replace  跳转不添加历史记录
router.go       跳转到某一条记录
router.back  返回
router.forward  前进
router.addRoutes  动态添加路由配置

路由守卫：
全局类守卫：beforeEach beforeResolve afterEach(钩子函数)
路由独享守卫:beforeEnter 在router(routes)里面定义
router.beforeEach(function(to,from,next){
    console.log(to)  到哪去
    console.log(from)从哪来
    console.log(next) 下一步
        类似于push
        1.path路径
        2.对象(path name)
        3.false  禁止通过
})
组件内的守卫：beforeRouteEnter  渲染组件之前
    beforeRouteUpdate 动态路由
beforeRouteLeave  离开组件之前


配置文件：(vue-cli)
	配置文件：webpack.config.js
特点：功能丰富 易于扩展 无需Eject 即刻创建原型 面向未来 
安装：cnpm/npm install -g @vue/cli
创建项目：vue create 文件夹名称
查看版本号：vue --version
运行：npm run serve
打包：npm run build
创建好的项目：
            .git文件夹   git本地版本库(勿动)
            node_modules  依赖包
            public  静态资源 index入口文件
            src  逻辑代码
            .gitignore  :git提交时忽略的文件
            babel.config.js  :babel配置文件
            package.json  :npm的配置文件
            package-lock.json  (勿动)
            README.md  :项目的帮助文件


头条：
	安装swiper npm i --save swiper
安装路由： npm i --save vue-router
安装resource  cnpm i vue-resource     
每个安装的插件都在main.js中引用
vue config.js    vue-cli里面配置文件的devserve(需要重启)


vue-axios:
	Vue插件的一般功能：
                添加全局方法和属性
                添加全局资源
                通过全局混入来添加一些组件选项
                添加vue实例方法，
vue.use(vue-axios,axios)
安装 npm install --save  axios vue-axios
使用：   
    全局方法  this.axios.get(api).then((response)={})
    实例方法  this.axios. get(api).then((response)={})
    别名  this.$http. get(api).then((response)={})  返回值是一个promise对象

this.$nextTick(function(){
    this.initSwiper()
})
this.swiper=setTtranslate(50)
this.swiper.touchEventsData.isTouched=true
this.swiper.allowTouchMove=true

this.swiper=setTtransition(500)

this.refrash="刷新中"
this.swiper.touchEventsData.isTouched=true
this.swiper.allowTouchMove=true
随机生成一个长度为10的数字数组
    var arr=[];
    var newArr=[];
    for(var i=0;i<10;i++){
        arr.push(parseInt(Math.random()*10));
    }
    arr.forEach((el)=>{
        if(newArr.indexOf(el)==-1){
            newArr.push(el);
        }
    })
    newArr.sort(function(a,b){
        return b-a;
    })
console.log(newArr);
vueX:
	vuex是一个专为Vue.js应用程序开发的状态管理模式，采用集中式存储管理应用的所有组件的状态
Vuex VS单纯的全局对象
        状态存储是响应式的
        能够监听到状态的变化
核心：state action mutations getters
在main.js中import引用
Vue.use(vuex)
var store=new vuex.Store({
     一般state状态都会通过computed来获取
    state里面的值不能修改，提交的时候没有记录，无法追踪状态修改
    全局的data
    state:{
        调用：$store.state.值
        num:10,
        one:30,
    },
    相当于全局的方法methods
    mutations:{
        里面的方法需要传state里面的值
        调用：this.$store.commit('mutations')
        第二个参数是mutations的第一个传参
        方法名(state,'参数'){

        }
    },
    全局的computed
    getters:{
        里面的方法需要传state里面的值
        调用：$store.getters.值
        return state.one
        方法名(state){
            return state.下面的里面的名字
        }
    },
    异步调用的mutations
    actions:{
        调用：$store.diapatch
        方法名(context){
            context ==vuex
        }
    }
})
vuex使用v-model
    computed:{
        get(){

        },
        set(){

        }
    }
辅助函数 在App.vue中
        import vuex from 'vuex'
        import {{mapstate}} from 'vuex'
    mapState
    mapGetter
    mapMutations
对象的解构赋值
import {mapState} from 'vuex';
// es6 拓展运算符 ...
var [a,...b] = [1,2,3,4,5,6]


render函数：
	ender :替换了el
把app组件选项对象，渲染到当前vue实例中
render:function(createElement){
    createElement(app)
}
createElement(arg1,arg2)


在router.js中把暴露出来的路径地址写在component

webpack 打包工具
四个核心概念：入口(empty中配置)   
             输出(output中配置)  
             loader(module下rules中配置)  
             插件(plugins中配置)
安装：
配置文件：webpack.config.js
        module.exports={
            entry:
            output:{
                path:__dirname,
                filename:''
            }
            配置loader的部分
            modules:{
                rules:[
                    {}
                ],
                
            }
        }


element:
	安装 npm i element-ui -S
main.js: import elementui from 'element-ui' (一般不引入，引入小部分范围)
import 'element-ui/lib/theme-chalk/index.css'
Vue.use(elementui)
elementui 返回值是一个对象
import {需要用的组件名字} from 'element-ui'
Vue.use(引用的组件名字)
v-for与v-if不能再同一个Dom上操作，写一个template

复习：
	简单实现一个数据双向绑定
    Object.defineProperty()
CSS旨在当前vue组件起作用的几种方法
    scoped modules(推荐) 自己约定类名
vue中v-on可以绑定多个方法吗
    可以 <div v-on:click="abc"></div>
Vue中操作真实dom的几种方法
$refs  $el 定义指令 在mounted和$nextTick后元素操作  

Vue2.0
	vue init webpack my-project